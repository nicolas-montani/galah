# Logstash Pipeline Configuration for Galah Honeypot
input {
  # Monitor Galah log files
  file {
    path => "/logs/galah.json"
    start_position => "beginning"
    codec => "json"
    tags => ["galah", "honeypot"]
    type => "galah_event"
  }
}

filter {
  # Only process Galah events
  if [type] == "galah_event" {
    
    # Parse timestamp field - Galah uses Go time format with duration suffix
    if [eventTime] {
      # Remove the Go duration suffix (e.g., "m=+1944.752569224") from eventTime
      mutate {
        gsub => [ "eventTime", " [+]0000 UTC m=\+[0-9.]+", " +0000" ]
      }
      # Use @timestamp field directly since it's already properly formatted
      if [@timestamp] {
        # Use the existing @timestamp field which is already in ISO format
        mutate {
          remove_field => [ "eventTime" ]
        }
      }
    }
    
    # Add GeoIP information for source IP
    if [srcIP] {
      geoip {
        source => "srcIP"
        target => "source"
        add_field => { "geoip_enabled" => "true" }
      }
      
      # Handle localhost IPs with fake geolocation for testing
      if [srcIP] == "127.0.0.1" or [srcIP] == "::1" {
        mutate {
          add_field => { 
            "[source][ip]" => "%{srcIP}"
            "[source][country_name]" => "Test Lab"
            "[source][city_name]" => "Localhost"
            "[source][continent_code]" => "XX"
            "[source][country_code2]" => "XX"
            "[source][location][lat]" => "40.7589"
            "[source][location][lon]" => "-73.9851"
          }
        }
        mutate {
          convert => { 
            "[source][location][lat]" => "float"
            "[source][location][lon]" => "float" 
          }
        }
      }
    }
    
    # Extract HTTP method and path for easier analysis
    if [httpRequest][method] {
      mutate {
        add_field => { "http_method" => "%{[httpRequest][method]}" }
      }
    }
    
    if [httpRequest][request] {
      mutate {
        add_field => { "http_path" => "%{[httpRequest][request]}" }
      }
      
      # Extract file extension from path
      if [http_path] =~ /\.([a-zA-Z0-9]+)(\?|$)/ {
        mutate {
          add_field => { "file_extension" => "%{http_path}" }
        }
        mutate {
          gsub => [ "file_extension", "^.*\.([a-zA-Z0-9]+)(\?.*)?$", "\1" ]
        }
      }
    }
    
    # Analyze attack patterns
    if [httpRequest][attackVectors] {
      mutate {
        add_field => { "has_attack_vectors" => "true" }
        add_field => { "attack_count" => "%{[httpRequest][attackVectors]}" }
      }
      ruby {
        code => "
          if event.get('[httpRequest][attackVectors]')
            event.set('attack_count', event.get('[httpRequest][attackVectors]').length)
          end
        "
      }
    }
    
    # Categorize response status
    if [httpResponse][status] {
      if [httpResponse][status] >= 200 and [httpResponse][status] < 300 {
        mutate { add_field => { "response_category" => "success" } }
      } else if [httpResponse][status] >= 300 and [httpResponse][status] < 400 {
        mutate { add_field => { "response_category" => "redirect" } }
      } else if [httpResponse][status] >= 400 and [httpResponse][status] < 500 {
        mutate { add_field => { "response_category" => "client_error" } }
      } else if [httpResponse][status] >= 500 {
        mutate { add_field => { "response_category" => "server_error" } }
      }
    }
    
    # Extract User-Agent classification
    if [httpRequest][userAgent] {
      # Common bot patterns
      if [httpRequest][userAgent] =~ /(?i)(bot|crawler|spider|scraper|wget|curl|python|java|scanner)/ {
        mutate { add_field => { "user_agent_category" => "bot" } }
      } else if [httpRequest][userAgent] =~ /(?i)(chrome|firefox|safari|edge|opera)/ {
        mutate { add_field => { "user_agent_category" => "browser" } }
      } else if [httpRequest][userAgent] =~ /(?i)(mobile|android|iphone|ipad)/ {
        mutate { add_field => { "user_agent_category" => "mobile" } }
      } else {
        mutate { add_field => { "user_agent_category" => "unknown" } }
      }
    }
    
    # Suricata rule matching enrichment
    if [suricataMatches] {
      mutate {
        add_field => { "has_suricata_matches" => "true" }
      }
      ruby {
        code => "
          if event.get('suricataMatches')
            event.set('suricata_rule_count', event.get('suricataMatches').length)
            # Extract all SIDs for easier filtering
            sids = event.get('suricataMatches').map { |match| match['sid'] }
            event.set('suricata_sids', sids.join(','))
          end
        "
      }
    } else {
      mutate {
        add_field => { "has_suricata_matches" => "false" }
        add_field => { "suricata_rule_count" => "0" }
      }
    }
    
    # Add threat intelligence fields
    mutate {
      add_field => { "honeypot_type" => "galah" }
      add_field => { "event_classification" => "honeypot_interaction" }
    }
    
    # Calculate request size if available
    if [httpRequest][body] {
      ruby {
        code => "
          body = event.get('[httpRequest][body]')
          if body
            event.set('request_body_size', body.bytesize)
          end
        "
      }
    }
    
    # LLM response analysis
    if [responseMetadata][info][provider] {
      mutate {
        add_field => { "llm_provider" => "%{[responseMetadata][info][provider]}" }
        add_field => { "llm_model" => "%{[responseMetadata][info][model]}" }
      }
    }
    
    # Session analysis
    if [httpRequest][sessionID] {
      mutate {
        add_field => { "session_id" => "%{[httpRequest][sessionID]}" }
      }
    }
    
    # Port-based service classification
    if [port] {
      if [port] == "80" or [port] == "8080" {
        mutate { add_field => { "service_type" => "http" } }
      } else if [port] == "443" or [port] == "8443" {
        mutate { add_field => { "service_type" => "https" } }
      } else {
        mutate { add_field => { "service_type" => "other" } }
      }
    }
  }
}

output {
  # Output to Elasticsearch with dynamic index naming
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
    index => "galah-events-%{+YYYY.MM.dd}"
    template_name => "galah"
    template => "/usr/share/logstash/templates/galah-template.json"
    template_overwrite => true
    manage_template => true
  }
  
  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}